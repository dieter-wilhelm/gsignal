# pulstran.R
# Copyright (C) 2019 Geert van Boxtel <gjmvanboxtel@gmail.com>
# Matlab/Octave signal package:
# Copyright (C) 2000 Paul Kienzle <pkienzle@users.sf.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING. If not, see
# <https://www.gnu.org/licenses/>.
#
# 20191126 Geert van Boxtel          First version for v0.1.0
#---------------------------------------------------------------------------------------------------------------------------------

#' Pulse train
#' 
#' Generate a train of pulses based on samples of a continuous function
#' 
#' Generate the signal \code{y <- sum(func(t + d, ...))} for each \code{d}. If \code{d} is a matrix of two columns,
#' the first column is the delay \code{d} and the second column is the amplitude \code{a}, and \code{y <- sum(a * func(t + d))}
#' for each \code{d, a}. Clearly, \code{func} must be a function which accepts a vector of times. Any extra arguments
#' needed for the function must be tagged on the end.
#' 
#' If instead of a function name you supply a pulse shape sampled at frequency \code{fs} (default 1 Hz), an interpolated
#' version of the pulse is added at each delay \code{d}. The interpolation stays within the the time range of the delayed pulse.
#' The interpolation method defaults to linear, but it can be any interpolation method accepted by the function \code{interp1}
#' 
#' @param t Time values at which \code{func} is evaluated, specified as a vector.
#' @param d Offset removed from the values of the array \code{t}, specified as a real vector, matrix, or array. You can apply
#' an optional gain factor to each delayed evaluation by specifying \code{d} as a two-column matrix, with offset defined in
#' column 1 and associated gain in column 2. If you specify \code{d} as a vector, the values are interpreted as delays only.
#' @param func Continuous function used to generate a pulse train based on its samples, specified as 'rectpuls', 'gauspuls',
#' 'tripuls', or a function handle. If you use \code{func} as a function handle, you can pass the function parameters as follows:
#' \code{y <- pulstran(t, d, 'gauspuls', 10e3, 0.5)}. This creates a pulse train using a 10 kHz Gaussian pulse with 50% bandwidth.
#' Alternatively, \code{func} can be a prototype function, specified as a vector. The interval of the function is given by
#' \code{[0, (length(p) - 1) / fs]}, and its samples are identically zero outside this interval. By default, linear interpolation
#' is used for generating delays.
#' @param fs Sample rate in Hz, specified as a real scalar.
#' @param method Interpolation method, specified as one of the options in this table:
#' \itemize{
#'   \item{'linear' (default). Linear interpolation. The interpolated value at a query point is based on linear interpolation
#'     of the values at neighboring grid points in each respective dimension. This is the default interpolation method.}
#'   \item{'nearest'. Nearest neighbor interpolation. The interpolated value at a query point is the value at the nearest
#'     sample grid point.}
#'   \item{'cubic'. Shape-preserving piecewise cubic interpolation. The interpolated value at a query point is based on
#'     a shape-preserving piecewise cubic interpolation of the values at neighboring grid points.}
#'   \item{'spline'. Spline interpolation using not-a-knot end conditions. The interpolated value at a query point is based
#'     on a cubic interpolation of the values at neighboring grid points in each respective dimension.}
#' }
#' Interpolation is performed by the \code{interp1()} function (library \code{pracma}).
#' @param ... Further arguments passed to \code{func}.
#' 
#' @return Pulse train generated by the function, returned as a vector.
#' 
#' @examples
#' 
#' fs <- 11025                   # arbitrary sample rate
#' f0 <- 100                     # pulse train sample rate
#' w <- 0.003                    # pulse width of 3 milliseconds
#' t <- seq(0, 0.1, 1/fs)        # define sample times
#' d <- seq(0,0.1, 1/f0)         # define pulse times
#' x <- pulstran(t, d, 'rectpuls', w)
#' plot((0:length(x)-1)*1000/fs, x, type = "l", ylab = "amplitude", xlab = "time (ms)",
#'     main = "rectpuls")
#'   
#' @author Original Matlab/Octave code Copyright (C) 2007 Sylvain Pelissier, \email{sylvain.pelissier@@gmail.com}.
#' Port to R by Geert van Boxtel \email{G.J.M.vanBoxtel@@gmail.com}.
#'
#' @export
#' 

# fs <- 11025
# f0 <- 100                     # pulse train sample rate
# w <- 0.003                    # pulse width of 3 milliseconds
# t <- seq(0, 0.1, 1/fs)        # define sample times
# d <- seq(0,0.1, 1/f0)         # define pulse times

pulstran <- function (t, d, func, fs = 1, method = c('linear', 'nearest', 'cubic', 'spline'), ...) {

  if (missing(t) || length(t) <= 0) stop ("t must be an array")
  if (missing(d) || length(d) <= 0) stop ("d must be an array, vector or a matrix")
  
  y <- rep(0L, length(t))
  if (is.vector(d) || (is.array(d) && length(dim(d)) == 1)) {
    a <- seq(1L, length(d))
  } else if ((is.matrix(d) || is.array(d)) && ncol(d) == 2) {
    d <- d[, 1]
    a <- d[, 2]
  } else stop('invalid value specified for d')

  if (is.character(func)) {
    for (i in 1:length(d)) {
      y <- y + a[i] * do.call(func, list(t - d[i], ...))
    }
  }
    # if ischar(pulse)
  #   ## apply function t+d for all d
  #   for i=1:rows(d)
  #     y = y+a(i)*feval(pulse,t-d(i,1),varargin{:});
  #   endfor
  # else
  #   ## interpolate each pulse at the specified times
  #   Fs = 1; method = 'linear';
  #   if nargin==4
  #     arg=varargin{1};
  #     if ischar(arg),
  #       method=arg;
  #     else
  #       Fs = arg;
  #     endif
  #   elseif nargin==5
  #     Fs = varargin{1};
  #     method = varargin{2};
  #   endif
  #   span = (length(pulse)-1)/Fs;
  #   t_pulse = (0:length(pulse)-1)/Fs;
  #   for i=1:rows(d)
  #     dt = t-d(i,1);
  #     idx = find(dt>=0 & dt<=span);
  #     y(idx) = y(idx) + a(i)*interp1(t_pulse, pulse, dt(idx), method);
  #   endfor
  # endif
  
}

# %!error pulstran
# %!error pulstran(1,2,3,4,5,6)
# 
# %!## parameter size and shape checking
# %!shared t,d
# %! t = 0:0.01:1; d=0:0.1:1;
# %!assert (isempty(pulstran([], d, 'sin')));
# %!assert (pulstran(t, [], 'sin'), zeros(size(t)));
# %!assert (isempty(pulstran([], d, boxcar(5))));
# %!assert (pulstran(t, [], boxcar(5)), zeros(size(t)));
# %!assert (size(pulstran(t,d,'sin')), size(t));
# %!assert (size(pulstran(t,d','sin')), size(t));
# %!assert (size(pulstran(t',d,'sin')), size(t'));
#           %!assert (size(pulstran(t,d','sin')), size(t));
# 
# %!demo
# %! fs = 11025;                   # arbitrary sample rate
# %! f0 = 100;                     # pulse train sample rate
# %! w = 0.003;                    # pulse width of 3 milliseconds
# %! t = 0:1/fs:0.1; d=0:1/f0:0.1; # define sample times and pulse times
# %! a = hanning(length(d));       # define pulse amplitudes
# %!
# %! subplot(221);
# %! x = pulstran(t', d', 'rectpuls', w);
# %! plot([0:length(x)-1]*1000/fs, x);
# %! hold on; plot(d*1000,ones(size(d)),'g*;pulse;'); hold off;
# %! ylabel("amplitude"); xlabel("time (ms)");
# %! title("rectpuls");
# %!
# %! subplot(223);
# %! x = pulstran(f0*t, [f0*d', a], 'sinc');
#                          %! plot([0:length(x)-1]*1000/fs, x);
#                          %! hold on; plot(d*1000,a,'g*;pulse;'); hold off;
#                          %! ylabel("amplitude"); xlabel("time (ms)");
#                          %! title("sinc => band limited interpolation");
#                          %!
#                            %! subplot(222);
#                          %! pulse = boxcar(30);  # pulse width of 3 ms at 10 kHz
#                          %! x = pulstran(t, d', pulse, 10000);
# %! plot([0:length(x)-1]*1000/fs, x);
# %! hold on; plot(d*1000,ones(size(d)),'g*;pulse;'); hold off;
# %! ylabel("amplitude"); xlabel("time (ms)");
# %! title("interpolated boxcar");
# %!
# %! subplot(224);
# %! pulse = sin(2*pi*[0:0.0001:w]/w).*[w:-0.0001:0];
# %! x = pulstran(t', [d', a], pulse', 10000);
#                          %! plot([0:length(x)-1]*1000/fs, x);
#                          %! hold on; plot(d*1000,a*w,'g*;pulse;'); hold off; title("");
#                          %! ylabel("amplitude"); xlabel("time (ms)");
#                          %! title("interpolated asymmetric sin");
#                          %!
#                            %! %----------------------------------------------------------
#                            %! % Should see (1) rectangular pulses centered on *,
#                          %! %            (2) rectangular pulses to the right of *,
#                          %! %            (3) smooth interpolation between the *'s, and
# %! %            (4) asymmetric sines to the right of *