% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filter.R
\name{filter}
\alias{filter}
\alias{filter.default}
\alias{filter.Arma}
\alias{filter.Ma}
\alias{filter.Sos}
\alias{filter.Zpg}
\title{Filter a signal}
\usage{
filter(filt, ...)

\method{filter}{default}(filt, a, x, init, init.x, init.y, ...)

\method{filter}{Arma}(filt, x, ...)

\method{filter}{Ma}(filt, x, ...)

\method{filter}{Sos}(filt, x, ...)

\method{filter}{Zpg}(filt, x, ...)
}
\arguments{
\item{filt}{For the default case, the moving-average coefficients of an ARMA
filter (normally called ‘b’). Generically, \code{filt} specifies an arbitrary
filter operation.}

\item{...}{additional arguments (ignored).}

\item{a}{the autoregressive (recursive) coefficients of an ARMA filter.}

\item{x}{the input signal to be filtered.}

\item{init.x}{initial data for the convolution part of the filter (FIR).}

\item{init.y, init}{initial data for the recursive part of the filter (IIR).}
}
\value{
The filtered signal, normally of the same length as the input signal
  \code{x}, returned as a vector
}
\description{
Apply a 1-D digital filter to the data in \code{x}, compatible with
Matlab/Octave.
}
\details{
\code{filter(b, a, x)} returns the solution to the following linear,
time-invariant difference equation:
\if{latex}{
  \deqn{\sum_{k=0}^{N} a(k+1) y(n-k) + \sum_{k=0}^{M} b(k+1) x(n-k) = 0; 1
  \le n \le length(x)}
}
\if{html}{\preformatted{
  N                  M
 SUM a(k+1)y(n-k) + SUM b(k+1)x(n-k) = 0;   1 <= n <= length(x)
 k=0                k=0
}}
where \code{N = length(a) - 1} and \code{M = length(b) - 1}.

An equivalent form of this equation is:
\if{latex}{
  \deqn{y(n) = \sum_{k=1}^{N} c(k+1) y(n-k) + \sum_{k=0}^{M} d(k+1) x(n-k); 1
  \le n \le length(x)}
}
\if{html}{\preformatted{
          N                  M
  y(n) = SUM c(k+1)y(n+k) + SUM d(k+1)x(n-k);   1 <=n <= length(x)
         k=1                k=1
}}
where \code{c = a/a(1)} and \code{d = b/a(1)}.

Specifying \code{init.x}, \code{init.y}, or \code{init} (alias of
\code{init.y}) allows filtering very large time series in pieces in case of
limited computer memory. This works by passing the last \code{M} data points
of the truncated input series \code{x} for the convolution part to
\code{init.x}, or the last \code{N} data points of the truncated output
series \code{y} to \code{init.y}. See the examples.

The default filter calls \code{\link[stats]{filter}}, which returns an object
of class \code{\link{ts}}. However, the output of \code{filter} is converted
to a vector before the result is returned.
}
\examples{
bf <- butter(3, 0.1)                                 # 10 Hz low-pass filter
t <- seq(0, 1, len = 100)                            # 1 second sample
x <- sin(2* pi * t * 2.3) + 0.25 * rnorm(length(t))  # 2.3 Hz sinusoid+noise
z <- filter(bf, x)                                   # apply filter
plot(t, x, type = "l")
lines(t, z, col = "red")

## example of filtering data in pieces (FIR)
b <- c(1, 1); a <- 1
x <- 1:100
y <- filter(b, a, x)
x1 <- x[1:50]
x2 <- x[51:100]
y1 <- filter(b, a, x1)
y2 <- filter(b, a, x2, init.x = x1[(length(x1) - (length(b) - 1) + 1):length(x1)])
all.equal(as.numeric(y), c(y1,y2))

## example of filtering data in pieces (IIR)
b <- 1; a <- c(1,1)
x <- 1:100
y <- filter(b, a, x)
x1 <- x[1:50]
x2 <- x[51:100]
y1 <- filter(b, a, x1)
y2 <- filter(b, a, x2, init = y1[(length(y1) - (length(a) - 1) + 1):length(y1)])
all.equal(as.numeric(y), c(y1,y2))

}
\seealso{
\code{\link[stats]{filter}} in the \code{stats} package
}
\author{
Tom Short, \email{tshort@eprisolutions.com},\cr
 adapted by Geert van Boxtel, \email{G.J.M.vanBoxtel@gmail.com}.
}
